数值类型 — int, float, long, complex

有四种不同的数值类型：普通整数、长整数、浮点数和复数。此外，布尔值是普通整数的一个子类型。普通整数（或者简称整数）使用C中的long实现，其精度至少为32位（sys.maxint始终设置为当前平台最大的普通整数值，最小值是-sys.maxint - 1)。长整数具有无限的精度。浮点数字通常使用C中的double实现；有关你的程序所运行的机器上的浮点数精度及其内部表示形式的信息在sys.float_info中可以获得。复数有实部和虚部，各是一个浮点数。若要从复数z中提取这些部分，请使用z.real和z.imag。（标准库包括额外的数值类型，fractions支持有理数，decimal支持用户自定义精度的浮点数。）

数值通过数字字面值或内建的函数和操作的结果创建。普通的整数字面值（包括二进制、十六进制和八进制数字）产生普通整数，除非它们指定的值太大以致不能用一个普通的整数表示，在这种情况下它们产生一个长整型。带有'L'或'l'后缀的整数字面值产生长整数（偏向使用'L'，因为1l看起来太像十一）。包含小数点或指数符号的数字字面值产生浮点数。将'j'或'J'附加到数字字面值的尾部产生实部为零的复数。复数字面值是实部和虚部的和。

Python完全支持混合的算法：当二元算术运算符的操作数是不同的数值类型时，“较窄”类型的操作数会拓宽成另外一个操作数的类型，其中整数窄于长整数窄于浮点数窄于复数。比较混合型数字之间使用相同的规则。[2]构造函数int()、long()、float()和complex()可用于产生的一种特定类型的数值。

所有内置的数值类型都支持以下操作。运算符的优先级请参阅幂运算符和后面几节。
操作  结果  注
x + y   x与y和     
x - y   x与y的差    
x * y   x与y的积    
x / y   x与y的商   (1)
x // y  x与y的（整除）商   (4)(5)
x % y   x / y的余数    (4)
-x  负x   
+x  x保持不变    
abs(x)  x的绝对值或大小    (3)
int(x)  x转换成整数  (2)
long(x)     x转换成长整数     (2)
float(x)    x转换成浮点数     (6)
complex(re,im)  实部为re，虚部为im的一个复数。im默认为零。     
c.conjugate()   复数c的共轭。（用实数表示）   
divmod(x, y)    元组(x // y, x % y)   (3)(4)
pow(x, y)   x的y次方   (3)(7)
x ** y  x的y次方   (7)

注：

    对于（普通或长）整数除法，结果是一个整数。结果总是向负无穷舍入：1/2是0，(-1)/2是-1，1/(-2)是-1，（-1)/(-2)是0。请注意如果任何一个操作数是长整数，结果都会是一个长整数，与值大小无关。

    使用int()或long()函数转换浮点数会向零截断，类似相关的函数math.trunc()函数。使用函数math.floor()以向下取整和math.ceil()以向上取整。

    完整的说明请参阅内置函数。

    从2.3版开始弃用：整除运算符、取模运算符和divmod()函数不再为复数定义。相反，如果合适，可以使用abs()函数转换为浮点数。

    也被称为整数除法。结果的值完全是一个整数，虽然结果的类型不一定是整型。

    浮点数还接受可带有可选前缀 "+"或"-"的字符串"nan"和"inf"来表示非数字（NaN)）和正/负无穷。

    在2.6版中新增。

    Python定义pow(0,0)和0 ** 0为1，这对于编程语言很常见。

所有的numbers.Real类型（int、long和float）还包含以下的操作：
操作  结果  注
math.trunc(x)   x截取成整数   
round(x[, n])   x舍入到n位，舍入ties away from零。如果n省略，默认为0。     
math.floor(x)   <= x的最大浮点整数      
math.ceil(x)    >= x的最小浮点整数      
5.4.1. 整数类型的位操作

按位运算只有对整数才有意义。负数被视为它们2的补值（这假定操作过程中有足够多的位数而没有发生溢出）。

二元位运算的优先级都低于数值操作，但高于比较操作；一元操作~具有和其它的一元数值操作（+和-）相同的优先级。

下表按优先级升序排列列出位运算（在同一格中的操作具有相同的优先级）：
操作  结果  注
x | y   x和y的按位或      
x ^ y   x和y的按位异或     
x & y   x和y的按位与      
x << n  x左移n位   (1)(2)
x >> n  x右移n位   (1)(3)
~x  反转x的各个位      

注：

    负的移位数目是非法的并导致引发一个ValueError。
    左移n等同于乘以pow(2, n)。如果结果超过普通整数的范围则返回一个长整数。
    右移n位等同于除以pow(2, n)。

5.4.2. 整数类型的其它方法

整数类型实现numbers.Integral 抽象基类。另外，它们多提供一个方法：

int.bit_length()

long.bit_length()

    返回以二进制表示一个整数必须的位数，不包括符号和前导零：
    >>>

    >>> n = -37
    >>> bin(n)
    '-0b100101'
    >>> n.bit_length()
    6

    更确切地说，如果x不为零，那么x.bit_length()是唯一的正整数k使得2**(k-1) < = abs(x) < 2 * * k。等价的说， 当 abs(x)足够小并有一个正确的舍入对数，那么k = + 1 int(log(abs(x)， 2))。如果x为零，则x.bit_length()将返回0。

    相当于：

    def bit_length(self):
        s = bin(self)       # binary representation:  bin(-37) --> '-0b100101'
        s = s.lstrip('-0b') # remove leading zeros and minus sign
        return len(s)       # len('100101') --> 6

    2.7版中新增。

5.4.3. 浮点数的其它方法

浮点类型实现自numbers.Real 抽象基类。浮点数还具有以下的其它方法。

float.as_integer_ratio()

    返回一对整数，它们的比例准确地等于浮点数的原始值，且分母为正数。无穷引发ValueError，NaNs引发OverflowError 。

    2.6版中新增。

float.is_integer()

    如果浮点数实例有有限个整数值，则返回True，否则返回False：
    >>>

    >>> (-2.0).is_integer()
    True
    >>> (3.2).is_integer()
    False

    2.6版中新增。

两种方法都支持与十六进制字符串的相互转换。由于Python的浮点数内部存储为二进制数，浮点数和十进制字符串通之间的相互转化通常会有一个小的舍入误差。与此相反的是，十六进制字符串允许浮点数的精确表示和规格。这在调试时和数值工作中很有用。

float.hex()

    返回浮点数的十六进制字符串表示形式。对于有限的浮点数，这种表示形式总是包括一个前导的0x和尾部p及指数。

    2.6版中新增。

float.fromhex(s)

    类方法，返回十六进制字符串s表示的浮点数。字符串s可以有前导和尾随空白。

    2.6版中新增。

请注意， float.hex()是实例方法，而float.fromhex()是一个类方法。

十六进制字符串的形式为：

[sign] ['0x'] integer ['.' fraction] ['p' exponent]

可选的sign可以为+或-，integer和fraction是十六进制数的字符串，exponent是带有可选的前导符号的十进制整数。大小写不敏感，且整数或小数至少有一个十六进制数字。此语法类似于C99 标准的第6.4.4.2节中指明的语法，也类似Java 1.5起使用的语法。特别地，float.hex()的输出在C或Java代码中可作为十六进制浮点数的字面值，而且C的%a格式的十六进制字符串或Java的Double.toHexString可以被float.fromhex()接受。

注意指数是用十进制数而不是十六进制表示，并且它给出用来乘系数的2的幂。例如，十六进制的字符串0x3.a7p10表示浮点数(3 + 10./16 + 7./16**2) * 2.0**10，或3740.0：
>>>

>>> float.fromhex('0x3.a7p10')
3740.0

应用反向转换为3740.0给出了一个不同的十六进制字符串表示的相同数目：
>>>

>>> float.hex(3740.0)
'0x1.d380000000000p+11'

